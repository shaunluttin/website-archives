
<!DOCTYPE html> 
<html lang="en-US" class="static detail-blog-post dir-ltr contents" dir="ltr"> 

<!-- Mirrored from www.muddlingthru.ca/query-expressions by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 09 Dec 2022 06:14:24 GMT -->
<head> 
    <meta charset="utf-8" />
    <title>Muddling Thru - Query expressions</title> 
    <link href="http://fonts.googleapis.com/css?family=Lobster&amp;subset=latin" rel="stylesheet" type="text/css" />
<link href="Themes/Bootstrap_3_3_4_Base/Styles/base.css" rel="stylesheet" type="text/css" />
<link href="Themes/Bootstrap_3_3_4_SimpleBlog/Styles/theme.css" rel="stylesheet" type="text/css" />
<!--[if lt IE 9]>
<script src="/Core/Shapes/scripts/html5.js" type="text/javascript"></script>
<![endif]-->
<meta content="Orchard" name="generator" />
<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" />
<link href="modules/orchard.themes/Content/orchard.ico" rel="shortcut icon" type="image/x-icon" />

<link rel="alternate" type="application/rss+xml" title="Muddling Thru" href="rss91cc?containerid=12" />

    <script>(function(d){d.className="dyn"+d.className.substring(6,d.className.length);})(document.documentElement);</script> 
    <script>window.isRTL = false;</script>
</head> 
<body>


<div class="aside-1" id="layout-wrapper">
<header id="layout-header" class="group">
    <div id="header">
        <div class="zone zone-header"><h1 id="branding"><a href="index.html">Muddling Thru</a></h1>
</div>
    </div>
</header>
<div id="layout-navigation" class="group">
    <div class="zone zone-navigation">
<article class="widget-navigation widget-menu-widget widget">
    
<nav>
    <ul class="menu menu-main-menu">
        
        
    </ul>
</nav>
</article>
<article class="widget-navigation widget-html-widget widget">
    <p>Welcome to&nbsp;<a href="http://www.shaunluttin.com/">Shaun Luttin's</a> public notebook. It contains rough, practical notes. The guiding idea is that, despite what marketing tells us, there are no experts at anything. Sharing our half-baked ideas helps everyone. <strong>We're all just muddling thru</strong>. Find out more about our work at <a href="http://www.bigfont.ca/">bigfont.ca.</a></p>
</article></div>
</div>
<div id="layout-main-container">
<div id="layout-main" class="group">
    <aside id="aside-first" class="aside-first group">
        <div class="zone zone-aside-first">
<article class="widget-aside-first widget-search-form widget">
    
<form action="DISABLED_SEARCH_FORM_ACTION" class="search-form form form-inline" method="get">    <fieldset disabled>
        <input class="form-control input-lg" id="q" name="q" placeholder="Search" type="text" value="" />
        <button class="btn btn-default btn-lg" type="submit">Search!</button>
    </fieldset>
</form>
</article>
<article class="widget-aside-first widget-html-widget widget">
    <p><img class="img-thumbnail" alt="" src="Media/Default/Website-UI-Uploads/business_happy_200x200.jpg" height="200" width="200" /></p>
</article></div>
    </aside>
    <div id="layout-content" class="group">
                        <div id="content" class="group">
            <div class="zone zone-content">
<article class="blog-post content-item">
    <header>
        

<h1>Query expressions</h1>

    <p class="tags">
        <span>Tags:</span>
<a href="Tags/csharp-language-specification.html">csharp-language-specification</a>, <a href="Tags/c%23.html">c#</a>    </p>

            <div class="metadata">
                <div class="published">Wednesday, April 15, 2015 1:50:12 PM</div>
            </div>
    </header>
    <p><blockquote> <p>DRAFT DRAFT DRAFT DRAFT </p></blockquote> <p>These are my raw notes on section 7.16 of the C# Language Specification. Section 7.16 falls within section 7 on expressions. </p> <h4>Heuristic Model</h4> <ol> <li><strong>Notes</strong>. Add notes for each section.  <li><strong>Definitions</strong>. Add definitions for the chapter.  <li><strong>Examples</strong>. After adding definitions, then add examples.  <li><strong>Edit</strong>. After adding examples, then edit for readability etc.</li></ol> <h4>My Personal Conventions</h4> <ul> <li>terminology is <em>italicized</em>  <li>code is in <code>back ticks</code></li></ul> <h3>Intro</h3> <p>query expression syntax is similar to that of relational and hierarchical query languages</p> <ul> <li>begins with <code>from</code> clause  <li>ends with either <code>select</code> or <code>group</code> clause  <li>after the initial <code>from</code> can come zero or more of these clauses  <ul> <li><code>from</code>  <li><code>let</code>  <li><code>where</code>  <li><code>join</code>  <li><code>orderby</code></li></ul> <li>each <code>from</code> clause is a generator and includes:  <ul> <li>a range variable...  <li>which ranges over the elements of a sequence</li></ul> <li>each <code>let</code> clause  <ul> <li>introduces a range variable  <li>representing a value computed by means of previous range variables</li></ul> <li>each <code>where</code> clause  <ul> <li>is a filter  <li>that excludes items from the result</li></ul> <li>each <code>join</code> clause  <ul> <li>compares specified keys of the source sequence  <li>with keys of another sequence  <li>yielding matching pairs</li></ul> <li>each <code>orderby</code> clause  <ul> <li>reorders items  <li>according to specified criteria</li></ul> <li>the final <code>select</code> or <code>group</code> clause  <ul> <li>specified the shape of the result  <li>in terms of the range variables</li></ul> <li>an <code>into</code> clause  <ul> <li>can "splice" queries  <li>by treating the results of one query  <li>as a generator in a subsequent query</li></ul></li></ul> <h3>Ambiguities</h3> <p>The way to mixing contextual keywords into strings.</p> <ul> <li><code>from</code>  <li><code>where</code>  <li><code>join</code>  <li><code>on</code>  <li><code>equals</code>  <li><code>into</code>  <li><code>let</code>  <li><code>orderby</code>  <li><code>ascending</code>  <li><code>descending</code>  <li><code>select</code>  <li><code>group</code>  <li><code>by</code></li></ul> <p>The above are keywords when they occur <em>anywhere</em> within a query expression. </p> <p>To use these keywords within a query expression, prefix them with @</p> <p>from @select<br>in (new string[] { "from", "select" })<br>select @select</p> <p>Where a query expression is any expressions that</p> <ul> <li>starts with <code>from &lt;em&gt;identifier</code></em>  <li>followed by any token except <code>;</code> <code>=</code> or <code>,</code></li></ul> <h3>Translation</h3> <p>The steps for turning a query expression into fluent syntax.</p> <ul> <li>C# does not specify the execution semantics of query expressions.  <li>Rather, the compiler translates query expressions into methods</li></ul> <table cellspacing="0" cellpadding="2" width="320" border="1"> <tbody> <tr> <td valign="top" width="160">&nbsp;</td> <td valign="top" width="160">Where</td></tr> <tr> <td valign="top" width="160">&nbsp;</td> <td valign="top" width="160">Select</td></tr> <tr> <td valign="top" width="160">&nbsp;</td> <td valign="top" width="160">SelectMany</td></tr> <tr> <td valign="top" width="160">&nbsp;</td> <td valign="top" width="160">Join</td></tr> <tr> <td valign="top" width="160">&nbsp;</td> <td valign="top" width="160">GroupJoin</td></tr> <tr> <td valign="top" width="160">&nbsp;</td> <td valign="top" width="160">OrderBy</td></tr> <tr> <td valign="top" width="160">&nbsp;</td> <td valign="top" width="160">OrderByDescending</td></tr> <tr> <td valign="top" width="160">&nbsp;</td> <td valign="top" width="160">ThenBy</td></tr> <tr> <td valign="top" width="160">&nbsp;</td> <td valign="top" width="160">ThenByDescending</td></tr> <tr> <td valign="top" width="160">&nbsp;</td> <td valign="top" width="160">GroupBy</td></tr> <tr> <td valign="top" width="160">&nbsp;</td> <td valign="top" width="160">Cast</td></tr></tbody></table> <ul> <li>These methods must have particular  <ul> <li>signatures  <li>result types</li></ul> <li>These methods can be  <ul> <li>instance methods of the object being queried, or  <li>extension methods that are external to the object.  <li>[I'd like to see an example of override the Linq Extension Methods]</li></ul> <li>The translation:  <ul> <li>is a syntactic mapping  <li>occurs prior to any type binding or overload resolution  <li>is guaranteed to be <u>syntactically correct</u>  <li>is NOT guaranteed to produce <u>semantically correct</u> C# code</li></ul> <li>After the translation:  <ul> <li>the resulting methods are invoked as regular methods  <li>and this may result in normal method call errors</li></ul> <li>The compiler repeats the following translation until further reductions are impossible  <ul> <li>the compiler applies each translation section in order  <li>each section is applied exhaustively  <li>once exhausted, a section is not later revisited in the same query</li></ul> <li>Two notes:  <ul> <li>assignment to range variables is NOT allowed in a query expression, though this rule need not be strictly enforced in all C# implementations  <li>certain translations inject range variables with <em>transparent identifiers</em> denoted by <em></li></ul></li></ul> <h4>1. <code>Select</code> and <code>groupby</code> clauses with continuations</h4> <ul> <li>from ... into x ...  <li>translates into  <li>from x in ( from ... ) ...</li></ul> <p><strong>Example</strong></p> <p><font style="background-color: #00ff00">from c in customers group c by c.Country</font> <strong><font style="background-color: #ffff00">into g</font></strong> <font style="background-color: #dfce04">select new { Country = g.Key }</font></p> <p><font style="background-color: #ffff00"></font>becomes<font style="background-color: #ffff00"></font></p> <p><strong><font style="background-color: #ffff00">from </font><font style="background-color: #ffff00">g </font></strong><font style="background-color: #ffff00">in</font> ( <font style="background-color: #00ff00">from c in customers group c by c.Country</font> ) <font style="background-color: #dfce04">select new { Country = g.Key</font><font style="background-color: #dfce04"> }</font></p> <p><font style="background-color: #dfce04"></font>then becomes</p> <p><font style="background-color: #00ff00">customers.GroupBy(c =&gt; c.Country)</font>.<font style="background-color: #ffff00"><font style="background-color: #dfce04">Select</font></font>(<font style="background-color: #ffff00">g</font> =&gt; <font style="background-color: #dfce04">new { Country = g.Key }</font>)</p> <h4>2. Explicit range variable types</h4> <p>from</p> <ul> <li>from T x in e  <li>translates into  <li>from x in (e).Cast&lt;T&gt;()</li></ul> <p>join</p> <ul> <li>join T x in e on k1 equals k2  <li>translates into  <li>join x in ( e ).Cast&lt;T&gt;() on k1 equals k2</li></ul> <p><strong>Example</strong></p> <p>from Customer c in customers where c.City == "London" select c</p> <p>becomes</p> <p>from c in customers.Cast&lt;Customer&gt;() where c.City == "London" select c</p> <p>then becomes</p> <p>customers.Cast&lt;Customer&gt;().Where(c =&gt; c.City == "London")</p> <p><strong>Note</strong></p> <p>The .Cast&lt;T&gt;() operates on each object in the collection (as opposed to casting the collection).</p> <h4>3. Degenerate query expressions</h4> <p>A degenerate query expression is one the trivially selects the elements from the source. </p> <ul> <li>from x in e select x  <li>translates into  <li>( e ).Select(x =&gt; x)</li></ul> <p><strong>Example</strong></p> <p>from c in customers select c</p> <p>becomes</p> <p>customers.Select(c =&gt; c)</p> <p><strong>Notes</strong></p> <ul> <li>if a query expression includes only a degenerate query,  <ul> <li>then the translation appends a .Select()</li></ul> <li>that said, if there are further translations  <ul> <li>a later phase of the translation  <li>will replace the degenerate query with just its source</li></ul> <li>This happens because...  <ul> <li>it is important to ensure that the result of a query expression is not the source  <li>lest we reveal the type and identity of the source to the client of the query  <li>[why would that be problematic?]</li></ul></li></ul> <h4>4. <code>From</code>, <code>let</code>, <code>where</code>, <code>join</code>, and <code>orderby</code> clauses</h4> <p>A query expression with a...</p> <h5>...second <code>from</code> clause followed by a...</h5> <ul> <li>This is the SelectMany. It isn't a query continuation.  <li>The <code>select</code> clause has access to the range variable from both the first and second <code>from</code> clauses.</li></ul> <p>... <code>select</code> clause</p> <ul> <li>from x1 in e1 from x2 in e2 select v  <li>( e1 ) . SelectMany ( x1 =&gt; e2, ( x1 , x2 ) =&gt; v )  <li>from<font style="background-color: #ffff00"> c </font>in customers from<font style="background-color: #ffff00"> o </font>in c.Orders select new { c.Name, o.OrderId, o.Total }  <li>customers.SelectMany(c =&gt; c.Orders, (<font style="background-color: #ffff00">c, o</font>) =&gt; new { c.Name, o.OrderId, o.Total } )</li></ul> <p>something other than a <code>select</code> clause</p> <ul> <li>from x1 in e1 from x2 in e2 ...  <li>from * in ( e1 ) . SelectMany( x1 =&gt; e2 , ( x1, x2 ) =&gt; new { x1, x2 } )  <li>from<font style="background-color: #ffff00"> c </font>in customers from<font style="background-color: #ffff00"> o </font>in c.Orders...  <li>from * in customers.SelectMany( c =&gt; c.Orders, ( c, o ) =&gt; new <font style="background-color: #ffff00">{ c, o }</font> ) ...</li></ul> <p>Recall that the * is the transparent identifier. It captures multiple range variables and later becomes an anonymous object or function. In the above case, it later becomes new { x1, x2 }</p> <p>Note, in both the above examples, the <font style="background-color: #ffff00">range variables</font> of both <code>from</code> clauses stay in scope; that is, both are available in subsequent clauses. </p> <h5><code>let</code> clause</h5> <p>The variable defined within the let clause has access to the initial range variable and, along with it, is available through the rest of the query. </p> <ul> <li>from x in e let y = f ...  <li>from * in ( e ) . Select ( x =&gt; new { x, y = f } ) ...  <li>from o in orders let t = o.Details.Sum(d =&gt; d.UnitPrice * d.Quantity) ...  <li>from * in orders.Select(o =&gt; new { o, t = o.Details.Sum(d =&gt; d.UnitPrice * d.Quantity ) } ) ...</li></ul> <h5><code>where</code> clause</h5> <ul> <li>from x in e where f ...  <li>from x in ( e ).Where ( x =&gt; f )  <li>from o in orders where o.Id &gt; 0  <li>from o in orders.Where(o =&gt; o.Id &gt; 0)</li></ul> <h5><code>join</code> clause <u>without</u> an <code>into</code> followed by a </h5> <p><code>select</code> clause</p> <ul> <li>from x1 in e1 join x2 in e2 on k1 equals k2 select v  <li>( e1 ) . Join ( e2, x1 =&gt; k1, x2 =&gt; k2, ( x1, x2 ) =&gt; v )</li></ul> <p>something other than a <code>select</code> clause</p> <p>In this case, the transparent identifier * holds the place of the anonymous new { x1, x2 }</p> <ul> <li>from x1 in e1 join x2 in e2 on k1 equals k2  <li>from<font style="background-color: #ffff00"> * </font>in ( e1 ) . Join ( e2, x1 =&gt; k1, x2 =&gt; k2, ( x1, x2 ) =&gt; <font style="background-color: #ffff00">new { x1, x2 } </font>)</li></ul> <h5><code>join</code> clause with an <code>into</code> followed by a </h5> <p>The <code>into</code> makes the <code>join</code> into a group join.</p> <p><code>select</code> clause</p> <p>The output here is the initial range variable x1 and the group formed from the second range variable x2. In other words, x1 remains in scope but x2 doesn't because it's behind g.</p> <ul> <li>from x1 in e1 join x2 in e2 on k1 equals k2 into g select v  <li>( e1 ) . GroupJoin ( e2, x1 =&gt; k1, x2 =&gt; k2, ( x1, g ) =&gt; v )</li></ul> <p>something other than a <code>select</code> clause</p> <ul> <li>from x1 in e1 join x2 in e2 on k1 equals k2 into g ...  <li>from<font style="background-color: #ffff00"> * </font>in ( e1 ) . GroupJoin ( e2, x1 =&gt; k1, x2 =&gt; k2, ( x1, g ) =&gt; <font style="background-color: #ffff00">new { x1, g }</font> ) </li></ul> <h5><code>orderby</code> clause</h5> <ul> <li>from x in e orderby k1, k2, k3 ...  <li>( e ) . OrderBy ( k1 ) . ThenBy ( k2 ) . ThenBy ( k3 ) ...</li></ul> <p>followed by <code>descending</code></p> <ul> <li>( e ) . OrderByDescending ( k1 ) . ThenByDescending ( k2 ) ...</li></ul> <h4>5. <code>Select</code> clauses</h4> <ul> <li>from x in e select v  <li>( e ) . Select ( x =&gt; v )</li></ul> <p>The <code>=&amp;gt;</code> is a projection from each value of <code>x</code> into <code>v</code>. If <code>v</code>&nbsp; is simply a repeat of <code>x</code>, then the translation is just <code>( e )</code>.</p> <h4>6. <code>Group</code> <code>by</code> clauses</h4> <ul> <li>from x in e group v by k  <li>( e ) . GroupBy ( x =&gt; k , x =&gt; v )</li></ul> <p>The exception is when <code>v</code> is the identifier <code>x</code>, in which case the result is <code>( e ) . GroupBy ( x =&amp;gt; k )</code></p> <h4>7. Transparent identifiers</h4> <ul> <li>some translations *inject</em> range variables with transparent identifiers  <ul> <li>the <code>*</code> denotes these  <li>they are NOT a proper language feature  <li>rather, they exist only as an intermediate step during translation</li></ul> <li>further translation steps propagate the <code>*</code> into either  <ul> <li>anonymous functions  <li>anonymous object initializers</li></ul> <li>cases:  <ul> <li>when a <code>*</code> occurs as a parameter in an anonymous function,  <ul> <li>then the members of the associated anonymous type,  <li>are automatically in scope in the anonymous function body</li></ul> <li>when a <code>*</code> occurs as a member of a declarator in an anonymous object initializer  <ul> <li>then it introduces a member with a transparent identifier</li></ul></li></ul> <li>As described above, the <code>*</code> are always introduced with anonymous types  <li><strong>the intent is to capture multiple range variables as members of a single object</strong>  <li>a c# implementation is allowed to use a different mechanism to accomplish the same intent. </li></ul> <h3>Pattern</h3> <ul> <li>Types can implement this pattern to support query expressions on those types.  <li>Types have flexibility in how they implement query expressions.  <ul> <li>implement as  <ul> <li>instance methods or  <li>extensions methods,  <li>because the invocation syntax is identical</li></ul> <li>can request  <ul> <li>delegates or  <li>expression trees,  <li>because anonymous functions are convertible to both</li></ul></li></ul> <li>The following is the recommended shape of a generic type <code>C&amp;lt;T&amp;gt;</code> that supports query expressions.  <li>It's possible to implement this with a non-generic type.  <li>See more details in Specification-QueryPattern.</li></ul> <p>Terminology in Approximate Order of First Occurrence</p> <ul> <li><em>query expression</em>  <ul> <li>any expression that starts with "from identifier"  <li>followed by any token except:  <ul> <li><code>;</code>  <li><code>=</code>  <li><code>,</code>  <li>Prefix those with @ if we want to use any of those in a string.</li></ul></li></ul> <li><em>expression</em>  <ul> <li>a line of code  <li>that evaluates to a value</li></ul> <li><em>clause</em>  <ul> <li>a part of a statement  <li>that does not constitute a complete statement</li></ul> <li><em>generator</em>  <ul> <li>a special type of routine  <ul> <li>that controls the iteration behavior of a loop  <li>yields values one at a time</li></ul> <li>all generators are iterators  <li>generators are similar to functions that return arrays  <ul> <li>a generator has parameters  <li>other code can call a generator  <li>a generator generates a series of values</li></ul> <li>generators are different from functions that return arrays  <ul> <li>because generators yield values one at a time  <li>instead of returning all the values at once</li></ul> <li>a generator looks like a function but behaves like an iterator  <li><a title="https://en.wikipedia.org/wiki/Generator_%28computer_programming%29" href="https://en.wikipedia.org/wiki/Generator_(computer_programming)">https://en.wikipedia.org/wiki/Generator<em>%28computer</em>programming%29</a></li></ul> <li><em>range variable</em>  <ul> <li>create these in a <code>from</code> or <code>let</code> clause  <li>stores each subsequent value that a generator yields</li></ul> <li><em>ranges</em>  <li><em>sequence</em>  <ul> <li>read-only  <li>forward-only  <li>one item at a time  <li>can be lazily generated  <li>potentially infinite  <li><a title="http://stackoverflow.com/questions/2627172/the-difference-between-lists-and-sequences" href="http://stackoverflow.com/questions/2627172/the-difference-between-lists-and-sequences">http://stackoverflow.com/questions/2627172/the-difference-between-lists-and-sequences</a></li></ul> <li><em>token</em>  <ul> <li>white space and comments are not tokens  <li>the following are tokens  <ul> <li>identifier  <li>keyword  <li>integer-literal  <li>real-literal  <li>character-literal  <li>string-literal  <li>operator-or-punctuator</li></ul></li></ul> <li><em>range variable</em>  <li><em>sequence</em>  <li><strong><u>clauses and keywords</u></strong>  <ul> <li><code>from</code>  <li><code>select</code>  <li><code>group</code>  <li><code>by</code>  <li><code>let</code>  <li><code>where</code>  <li><code>join</code>  <li><code>on</code>  <li><code>equals</code>  <li><code>into</code>  <li><code>orderby</code>  <li><code>ascending</code>  <li><code>descending</code></li></ul> <li><em>splice</em>  <li><em>contextual keywords vs simple names</em>  <li><em>query expression translation</em>  <ul> <li><em>Where</em>  <li><em>Select</em>  <li><em>SelectMany</em>  <li><em>Join</em>  <li><em>GroupJoin</em>  <li><em>OrderBy</em>  <li><em>OrderByDescending</em>  <li><em>ThenBy</em>  <li><em>ThenByDescending</em>  <li><em>GroupBy</em>  <li><em>Cast</em></li></ul> <li><em>translation</em>  <ul> <li>first into another query  <li>then into Methods</li></ul> <li><em>range variables</em>  <ul> <li>the variable immediately following the <code>from</code></li></ul> <li><em>transparent identifier</em>  <ul> <li><em>represented with <code>*</code></em>  <li><em>exists only as an intermediate step in query translation</em>  <li><em>later steps turn it into anonymous functions or anonymous object initializers</em>  <li><em>tend to capture multiple range variables as members of a single object</em></li></ul> <li><em>explicit range variable type</em>  <li><em>degenerate query expressions</em>  <ul> <li>trivially selects the elements of the source  <li>[this prevents calling code from being able to modify the source]</li></ul> <li>identifier  <li>member declarator</li></ul></p>

</article></div>
        </div>
            </div>
</div>
</div>
<div id="layout-footer" class="group">
    <footer id="footer">
        <div id="footer-quad" class="group">
                                            </div>
        <div id="footer-sig" class="group">
            <div class="zone zone-footer"><div class="credits">
    <span class="poweredby">Powered by <a href="http://www.orchardproject.net/" target="_blank">Orchard</a></span>
    <span class="copyright">&#169; Bootstrap 3.3.4 Simple Blog 2015.</span>
</div>
<div class="user-display">
        <span class="user-actions"><a href="Users/Account/LogOna659.html?ReturnUrl=%2Fquery-expressions" rel="nofollow">Sign In</a></span>
</div></div>
        </div>
    </footer>
</div>
</div>
<script src="Themes/Bootstrap_3_3_4_Base/scripts/base.js" type="text/javascript"></script>
<script src="Themes/Bootstrap_3_3_4_Base/scripts/theme.js" type="text/javascript"></script>

</body>

<!-- Mirrored from www.muddlingthru.ca/query-expressions by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 09 Dec 2022 06:14:24 GMT -->
</html>